// openCypher Grammar (v1 Subset)
// Supports: MATCH, CREATE, SET, REMOVE, DELETE, MERGE, UNWIND, WHERE, RETURN, ORDER BY, LIMIT, SKIP, WITH

?start: query

query: single_part_query | multi_part_query

// Multi-part queries with WITH clause
multi_part_query: reading_clause+ with_clause+ final_query_part

// Single-part queries (without WITH)
single_part_query: read_query | write_query | update_query | unwind_query | return_only_query

// Final part of multi-part query (allows RETURN without MATCH)
final_query_part: read_query
                | return_only_query
                | write_query
                | update_query
                | unwind_query

return_only_query: return_clause order_by_clause? skip_clause? limit_clause?

read_query: match_clause where_clause? return_clause order_by_clause? skip_clause? limit_clause?

write_query: create_clause return_clause?
           | merge_clause return_clause?
           | match_clause where_clause? create_clause+ set_clause? return_clause? order_by_clause? skip_clause? limit_clause?

update_query: match_clause where_clause? (set_clause | remove_clause)* delete_clause? return_clause? order_by_clause? skip_clause? limit_clause?

unwind_query: unwind_clause+ where_clause? return_clause? order_by_clause? skip_clause? limit_clause?
            | unwind_clause+ where_clause? create_clause return_clause?
            | unwind_clause+ match_clause where_clause? return_clause? order_by_clause? skip_clause? limit_clause?

// Reading clauses that can precede WITH
reading_clause: match_clause where_clause?
              | unwind_clause

// WITH clause
with_clause: "WITH"i DISTINCT_KW? return_item ("," return_item)* where_clause? order_by_clause? skip_clause? limit_clause?

// MATCH clause
match_clause: "MATCH"i pattern ("," pattern)*

// CREATE clause
create_clause: "CREATE"i pattern ("," pattern)*

// UNWIND clause
unwind_clause: "UNWIND"i expression "AS"i variable

// SET clause
set_clause: "SET"i set_item ("," set_item)*

set_item: property_access "=" expression

// REMOVE clause
remove_clause: "REMOVE"i remove_item ("," remove_item)*

remove_item: property_access          -> remove_property
           | variable label           -> remove_label

// DELETE clause
delete_clause: "DETACH"i "DELETE"i variable ("," variable)*  -> detach_delete
             | "DELETE"i variable ("," variable)*            -> regular_delete

// MERGE clause
merge_clause: "MERGE"i pattern ("," pattern)* merge_action*

merge_action: on_create_clause | on_match_clause

on_create_clause: "ON"i "CREATE"i set_clause
on_match_clause: "ON"i "MATCH"i set_clause

pattern: node_pattern (relationship_pattern node_pattern)*

node_pattern: "(" variable? labels? properties? ")"

relationship_pattern: undirected_rel
                    | left_arrow_rel
                    | right_arrow_rel

undirected_rel: "-" "[" variable? rel_types? properties? "]" "-"
left_arrow_rel: "<-" "[" variable? rel_types? properties? "]" "-"
right_arrow_rel: "-" "[" variable? rel_types? properties? "]" "->"

// WHERE clause
where_clause: "WHERE"i expression

// RETURN clause
return_clause: "RETURN"i DISTINCT_KW? return_item ("," return_item)*

return_item: expression ("AS"i IDENTIFIER)?

// ORDER BY clause
order_by_clause: "ORDER"i "BY"i order_by_item ("," order_by_item)*

order_by_item: expression DIRECTION?

DIRECTION: /ASC/i | /DESC/i
DISTINCT_KW: /DISTINCT/i

// LIMIT and SKIP
limit_clause: "LIMIT"i INT
skip_clause: "SKIP"i INT

// Expressions
?expression: or_expr

or_expr: and_expr ("OR"i and_expr)*
and_expr: not_expr ("AND"i not_expr)*
not_expr: "NOT"i not_expr     -> not_operation
        | comparison_expr     -> not_passthrough

comparison_expr: add_expr (COMP_OP add_expr | string_match_op add_expr)?

string_match_op: "STARTS"i "WITH"i -> starts_with
               | "ENDS"i "WITH"i   -> ends_with
               | "CONTAINS"i       -> contains

COMP_OP: "=" | "<>" | "<" | ">" | "<=" | ">="

// Arithmetic operators with precedence
add_expr: mult_expr (ADD_OP mult_expr)*
mult_expr: unary_expr (MULT_OP unary_expr)*
unary_expr: "-" unary_expr  -> unary_minus
          | primary_expr    -> unary_passthrough

ADD_OP: "+" | "-"
MULT_OP: "*" | "/" | "%"

?primary_expr: function_call
             | property_access
             | case_expr
             | literal
             | variable
             | "(" expression ")"

function_call: FUNCTION_NAME "(" function_args? ")"

function_args: "*"                              -> count_star
             | "DISTINCT"i expression           -> distinct_arg
             | expression ("," expression)*     -> regular_args

FUNCTION_NAME: /COUNT|SUM|AVG|MIN|MAX|COLLECT|LENGTH|SUBSTRING|UPPER|LOWER|TRIM|COALESCE|toInteger|toFloat|toString|type/i

case_expr: "CASE"i when_clause+ ("ELSE"i expression)? "END"i

when_clause: "WHEN"i expression "THEN"i expression

property_access: variable "." IDENTIFIER

// Labels and types
labels: label+
label: ":" IDENTIFIER

rel_types: rel_type ("|" rel_type)*
rel_type: ":" IDENTIFIER

// Properties
properties: "{" property ("," property)* "}"
property: IDENTIFIER ":" expression

// Literals
?literal: INT           -> int_literal
        | FLOAT         -> float_literal
        | STRING        -> string_literal
        | TRUE          -> true_literal
        | FALSE         -> false_literal
        | NULL          -> null_literal
        | list_literal
        | map_literal

list_literal: "[" [expression ("," expression)*] "]"
map_literal: "{" [map_pair ("," map_pair)*] "}"
map_pair: (IDENTIFIER | STRING) ":" expression

// Variables and identifiers
variable: IDENTIFIER

// Terminals - Keywords must come before IDENTIFIER
TRUE: /true/i
FALSE: /false/i
NULL: /null/i
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/

INT: /[0-9]+/
FLOAT: /[0-9]+\.[0-9]+/
STRING: /"([^"\\]|\\.)*"/ | /'([^'\\]|\\.)*'/

// Whitespace
%import common.WS
%ignore WS

// Comments (optional, for future)
COMMENT: "//" /[^\n]*/
%ignore COMMENT
