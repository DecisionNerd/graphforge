// openCypher Grammar (v1 Subset)
// Supports: MATCH, CREATE, SET, REMOVE, DELETE, MERGE, UNWIND, WHERE, RETURN, ORDER BY, LIMIT, SKIP, WITH

?start: query

query: union_query | single_part_query | multi_part_query | with_query

// UNION queries - combines multiple query results
union_query: (single_part_query | multi_part_query) (union_clause (single_part_query | multi_part_query))+

union_clause: "UNION"i "ALL"i  -> union_all
            | "UNION"i          -> union_distinct

// Multi-part queries with WITH clause
// Allows: reading clauses, writing clauses, or both before WITH
multi_part_query: reading_or_writing_clauses+ with_clause+ final_query_part

// Allow any combination of reading and writing clauses before WITH
reading_or_writing_clauses: reading_clause | writing_clause

// Writing clauses that can precede WITH
writing_clause: create_clause
              | merge_clause

// Queries starting with WITH clause
with_query: with_clause+ final_query_part

// Single-part queries (without WITH)
single_part_query: read_query | write_query | update_query | unwind_query | call_query | return_only_query | reading_only_query

// Reading-only query: multiple reading clauses followed by RETURN
reading_only_query: reading_clause reading_clause+ where_clause? return_clause order_by_clause? skip_clause? limit_clause?

// Final part of multi-part query (allows RETURN without MATCH)
final_query_part: read_query
                | return_only_query
                | write_query
                | update_query
                | unwind_query
                | call_query

return_only_query: return_clause order_by_clause? skip_clause? limit_clause?

read_query: match_clause where_clause? optional_match_clause+ where_clause? return_clause order_by_clause? skip_clause? limit_clause?
          | match_clause where_clause? return_clause order_by_clause? skip_clause? limit_clause?
          | optional_match_clause where_clause? return_clause order_by_clause? skip_clause? limit_clause?

write_query: create_clause return_clause?
           | merge_clause set_clause? return_clause?
           | match_clause where_clause? create_clause+ set_clause? return_clause? order_by_clause? skip_clause? limit_clause?
           | match_clause where_clause? merge_clause+ set_clause? return_clause? order_by_clause? skip_clause? limit_clause?

update_query: match_clause where_clause? optional_match_clause+ where_clause? (set_clause | remove_clause)* delete_clause? return_clause? order_by_clause? skip_clause? limit_clause?
            | match_clause where_clause? (set_clause | remove_clause)* delete_clause? return_clause? order_by_clause? skip_clause? limit_clause?
            | optional_match_clause where_clause? (set_clause | remove_clause)* delete_clause? return_clause? order_by_clause? skip_clause? limit_clause?

unwind_query: unwind_clause+ where_clause? return_clause? order_by_clause? skip_clause? limit_clause?
            | unwind_clause+ where_clause? create_clause return_clause?
            | unwind_clause+ match_clause where_clause? return_clause? order_by_clause? skip_clause? limit_clause?

call_query: call_clause+ where_clause? return_clause? order_by_clause? skip_clause? limit_clause?
          | call_clause+ where_clause? create_clause return_clause?
          | call_clause+ match_clause where_clause? return_clause? order_by_clause? skip_clause? limit_clause?

// Reading clauses that can precede WITH
reading_clause: match_clause where_clause?
              | optional_match_clause where_clause?
              | unwind_clause
              | call_clause

// WITH clause
with_clause: "WITH"i DISTINCT_KW? return_item ("," return_item)* where_clause? order_by_clause? skip_clause? limit_clause?

// MATCH clause
match_clause: "MATCH"i pattern ("," pattern)*

// OPTIONAL MATCH clause
optional_match_clause: "OPTIONAL"i "MATCH"i pattern ("," pattern)*

// CREATE clause
create_clause: "CREATE"i pattern ("," pattern)*

// UNWIND clause
unwind_clause: "UNWIND"i expression "AS"i variable

// CALL clause for subqueries
call_clause: "CALL"i "{" query "}"

// SET clause
set_clause: "SET"i set_item ("," set_item)*

set_item: property_access "=" expression

// REMOVE clause
remove_clause: "REMOVE"i remove_item ("," remove_item)*

remove_item: property_access          -> remove_property
           | variable label           -> remove_label

// DELETE clause
delete_clause: "DETACH"i "DELETE"i variable ("," variable)*  -> detach_delete
             | "DELETE"i variable ("," variable)*            -> regular_delete

// MERGE clause
merge_clause: "MERGE"i pattern ("," pattern)* merge_action*

merge_action: on_create_clause | on_match_clause

on_create_clause: "ON"i "CREATE"i set_clause
on_match_clause: "ON"i "MATCH"i set_clause

// Pattern with optional path variable binding: p = (a)-[:R]->(b)
pattern: variable "=" pattern_parts  -> pattern_with_binding
       | pattern_parts               -> pattern_without_binding

pattern_parts: node_pattern (relationship_pattern node_pattern)*

node_pattern: "(" variable? labels? properties? ")"

relationship_pattern: undirected_rel
                    | left_arrow_rel
                    | right_arrow_rel

undirected_rel: "-" "[" variable? rel_types? var_length_range? properties? pattern_where? "]" "-"
left_arrow_rel: "<-" "[" variable? rel_types? var_length_range? properties? pattern_where? "]" "-"
right_arrow_rel: "-" "[" variable? rel_types? var_length_range? properties? pattern_where? "]" "->"

pattern_where: "WHERE"i expression

var_length_range: "*" INT ".." INT              -> var_length_min_max
                | "*" INT ".."                   -> var_length_min_only
                | "*" ".." INT                   -> var_length_max_only
                | "*"                            -> var_length_unbounded

// WHERE clause
where_clause: "WHERE"i expression

// RETURN clause
return_clause: "RETURN"i DISTINCT_KW? return_item ("," return_item)*

return_item: "*"                           -> return_all
           | expression ("AS"i IDENTIFIER)?  -> return_expression

// ORDER BY clause
order_by_clause: "ORDER"i "BY"i order_by_item ("," order_by_item)*

order_by_item: expression DIRECTION?

DIRECTION: /ASC/i | /DESC/i
DISTINCT_KW: /DISTINCT/i

// LIMIT and SKIP
limit_clause: "LIMIT"i INT
skip_clause: "SKIP"i INT

// Expressions
?expression: or_expr

or_expr: xor_expr ("OR"i xor_expr)*
xor_expr: and_expr ("XOR"i and_expr)*
and_expr: not_expr ("AND"i not_expr)*
not_expr: "NOT"i not_expr     -> not_operation
        | comparison_expr     -> not_passthrough

comparison_expr: add_expr (COMP_OP add_expr | string_match_op add_expr | null_check_op | in_op add_expr)?

null_check_op: "IS"i "NOT"i "NULL"i  -> is_not_null
             | "IS"i "NULL"i          -> is_null

string_match_op: "STARTS"i "WITH"i -> starts_with
               | "ENDS"i "WITH"i   -> ends_with
               | "CONTAINS"i       -> contains

in_op: "IN"i  -> in_operator

COMP_OP: "=" | "<>" | "<" | ">" | "<=" | ">="

// Arithmetic operators with precedence
add_expr: mult_expr (ADD_OP mult_expr)*
mult_expr: power_expr (MULT_OP power_expr)*
power_expr: unary_expr (POW_OP unary_expr)*
unary_expr: "-" unary_expr  -> unary_minus
          | primary_expr    -> unary_passthrough

ADD_OP: "+" | "-"
MULT_OP: "*" | "/" | "%"
POW_OP: "^"

?primary_expr: function_call
             | subscript
             | property_access
             | case_expr
             | exists_expr
             | count_expr
             | quantifier_expr
             | filter_expr
             | extract_expr
             | reduce_expr
             | literal
             | variable
             | "(" expression ")"

exists_expr: "EXISTS"i "{" single_part_query "}"
count_expr: "COUNT"i "{" single_part_query "}"

quantifier_expr: "ALL"i "(" variable "IN"i expression "WHERE"i expression ")"     -> all_quantifier
               | "ANY"i "(" variable "IN"i expression "WHERE"i expression ")"     -> any_quantifier
               | "NONE"i "(" variable "IN"i expression "WHERE"i expression ")"    -> none_quantifier
               | "SINGLE"i "(" variable "IN"i expression "WHERE"i expression ")"  -> single_quantifier

filter_expr: "FILTER"i "(" variable "IN"i expression "WHERE"i expression ")"
extract_expr: "EXTRACT"i "(" variable "IN"i expression "|" expression ")"
reduce_expr: "REDUCE"i "(" variable "=" expression "," variable "IN"i expression "|" expression ")"

function_call: FUNCTION_NAME "(" function_args? ")"

function_args: "*"                              -> count_star
             | "DISTINCT"i expression           -> distinct_arg
             | expression ("," expression)*     -> regular_args

case_expr: "CASE"i when_clause+ ("ELSE"i expression)? "END"i

when_clause: "WHEN"i expression "THEN"i expression

subscript: (variable | literal | function_call | property_access | subscript) "[" subscript_index "]"

subscript_index: expression ".." expression  -> slice_range
               | expression ".."             -> slice_from
               | ".." expression             -> slice_to
               | ".."                        -> slice_all
               | expression                  -> index_access

property_access: (variable | map_literal | list_literal) "." IDENTIFIER

// Labels and types
labels: ":" label_disjunction

label_disjunction: label_conjunction ("|" label_conjunction)*
label_conjunction: IDENTIFIER (":" IDENTIFIER)*

label: ":" IDENTIFIER

rel_types: rel_type ("|" rel_type)*
rel_type: ":" IDENTIFIER

// Properties
properties: "{" property ("," property)* "}"
property: IDENTIFIER ":" expression

// Literals
?literal: INT           -> int_literal
        | FLOAT         -> float_literal
        | STRING        -> string_literal
        | TRUE          -> true_literal
        | FALSE         -> false_literal
        | NULL          -> null_literal
        | list_literal
        | map_literal

list_literal: list_comprehension
            | pattern_comprehension
            | "[" [expression ("," expression)*] "]"

list_comprehension: "[" variable "IN"i expression comp_where_clause? comp_map_clause? "]"

pattern_comprehension: "[" pattern comp_where_clause? "|" expression "]"

comp_where_clause: "WHERE"i expression
comp_map_clause: "|" expression
map_literal: "{" [map_pair ("," map_pair)*] "}"
map_pair: (IDENTIFIER | STRING) ":" expression

// Variables and identifiers
variable: IDENTIFIER

// Terminals - Keywords must come before IDENTIFIER, but IDENTIFIER before FUNCTION_NAME
// This allows function names to be used as identifiers (e.g., AS nodes)
TRUE: /true/i
FALSE: /false/i
NULL: /null/i
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
FUNCTION_NAME: /relationships|percentiledisc|percentilecont|localdatetime|substring|toboolean|tointeger|tofloat|tostring|toupper|tolower|truncate|datetime|localtime|duration|distance|dangerous|coalesce|collect|replace|isempty|length|minute|second|reverse|ltrim|rtrim|exists|count|month|lower|upper|point|nodes|split|stdevp|stdev|trim|year|type|date|time|hour|tail|head|last|right|left|floor|round|range|ceil|sign|day|sum|avg|min|max|abs|size|labels|id/i

INT: /[0-9]+/
FLOAT: /[0-9]+\.[0-9]+/
STRING: /"([^"\\]|\\.)*"/ | /'([^'\\]|\\.)*'/

// Whitespace
%import common.WS
%ignore WS

// Comments (optional, for future)
COMMENT: "//" /[^\n]*/
%ignore COMMENT
